<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laberinto Din√°mico con Enemigos</title>
    <style>
        body {
            background: #0f172a;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            font-family: sans-serif;
            color: white;
        }

        #laberinto {
            display: grid;
            grid-template-columns: repeat(21, 30px);
            grid-template-rows: repeat(21, 30px);
            gap: 2px;
            margin-top: 20px;
        }

        .celda {
            width: 30px;
            height: 30px;
            background: #0f172a;
        }

        .pared {
            background: #1a2647;
        }

        .jugador {
            background: #00a2ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #00a2ff;
        }

        .meta {
            background: #28a745;
            border-radius: 5px;
            box-shadow: 0 0 10px #28a745;
        }

        .enemigo {
            background: #ff3030;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff0000;
        }
    </style>
</head>

<body>
    <h2>üèÉ ¬°Escapa del laberinto!</h2>
    <p>Usa las flechas. Los monstruos te perseguir√°n si te ven.</p>
    <div id="laberinto"></div>

    <script>
        const filas = 21;
        const columnas = 21;
        const laberinto = document.getElementById('laberinto');
        let mapa = [];
        let jugador = { x: 1, y: 1 };
        let enemigos = [];

        // Crear laberinto real usando DFS
        function generarLaberinto() {
            mapa = Array.from({ length: filas }, () => Array(columnas).fill(1));

            function tallar(x, y) {
                const dirs = [
                    [2, 0],
                    [-2, 0],
                    [0, 2],
                    [0, -2]
                ].sort(() => Math.random() - 0.5);

                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && ny > 0 && nx < columnas - 1 && ny < filas - 1 && mapa[ny][nx] === 1) {
                        mapa[ny - dy / 2][nx - dx / 2] = 0;
                        mapa[ny][nx] = 0;
                        tallar(nx, ny);
                    }
                }
            }

            // Empezar desde (1,1)
            mapa[1][1] = 0;
            tallar(1, 1);

            // Dejar la meta al otro lado
            mapa[filas - 2][columnas - 2] = 2;
        }

        // Dibujar laberinto y enemigos
        function dibujarLaberinto() {
            laberinto.innerHTML = '';
            for (let y = 0; y < filas; y++) {
                for (let x = 0; x < columnas; x++) {
                    const celda = document.createElement('div');
                    celda.classList.add('celda');
                    if (mapa[y][x] === 1) celda.classList.add('pared');
                    if (mapa[y][x] === 2) celda.classList.add('meta');
                    if (x === jugador.x && y === jugador.y) celda.classList.add('jugador');
                    for (const e of enemigos) {
                        if (e.x === x && e.y === y) celda.classList.add('enemigo');
                    }
                    laberinto.appendChild(celda);
                }
            }
        }

        // Movimiento jugador
        function moverJugador(dx, dy) {
            const nx = jugador.x + dx;
            const ny = jugador.y + dy;
            if (nx < 0 || ny < 0 || nx >= columnas || ny >= filas) return;
            if (mapa[ny][nx] === 1) return;
            jugador.x = nx;
            jugador.y = ny;

            if (mapa[ny][nx] === 2) {
                alert('üéâ ¬°Has ganado!');
                reiniciar();
            }

            verificarColision();
            dibujarLaberinto();
        }

        // A* para enemigos
        function astar(start, goal) {
            const openSet = [start];
            const cameFrom = {};
            const gScore = {};
            const fScore = {};
            const hash = p => `${p.x},${p.y}`;
            gScore[hash(start)] = 0;
            fScore[hash(start)] = Math.abs(start.x - goal.x) + Math.abs(start.y - goal.y);

            while (openSet.length) {
                let currentIdx = 0;
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore[hash(openSet[i])] < fScore[hash(openSet[currentIdx])]) currentIdx = i;
                }
                const current = openSet.splice(currentIdx, 1)[0];
                if (current.x === goal.x && current.y === goal.y) {
                    const path = [];
                    let temp = current;
                    while (hash(temp) in cameFrom) {
                        path.push(temp);
                        temp = cameFrom[hash(temp)];
                    }
                    path.reverse();
                    return path;
                }

                const vecinos = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const v of vecinos) {
                    if (v.x < 0 || v.y < 0 || v.x >= columnas || v.y >= filas) continue;
                    if (mapa[v.y][v.x] === 1) continue;
                    const tentative = gScore[hash(current)] + 1;
                    if (tentative < (gScore[hash(v)] || Infinity)) {
                        cameFrom[hash(v)] = current;
                        gScore[hash(v)] = tentative;
                        fScore[hash(v)] = tentative + Math.abs(v.x - goal.x) + Math.abs(v.y - goal.y);
                        if (!openSet.some(p => p.x === v.x && p.y === v.y)) openSet.push(v);
                    }
                }
            }
            return [];
        }

        // Movimiento enemigos
        function moverEnemigos() {
            for (const e of enemigos) {
                let moved = false;
                if (lineaVision(e, jugador)) {
                    const camino = astar(e, jugador);
                    if (camino.length > 0) {
                        e.x = camino[0].x;
                        e.y = camino[0].y;
                        moved = true;
                    }
                }
                if (!moved) {
                    const opciones = [
                        { x: e.x + 1, y: e.y },
                        { x: e.x - 1, y: e.y },
                        { x: e.x, y: e.y + 1 },
                        { x: e.x, y: e.y - 1 }
                    ].filter(p => p.x >= 0 && p.y >= 0 && p.x < columnas && p.y < filas && mapa[p.y][p.x] === 0);
                    if (opciones.length > 0) {
                        const move = opciones[Math.floor(Math.random() * opciones.length)];
                        e.x = move.x;
                        e.y = move.y;
                    }
                }
            }
            verificarColision();
            dibujarLaberinto();
        }

        // L√≠nea de visi√≥n (misma distancia, pero dentro de 6 casillas m√°ximo)
        function lineaVision(enemigo, jugador) {
            const dist = Math.abs(enemigo.x - jugador.x) + Math.abs(enemigo.y - jugador.y);
            if (dist > 6) return false; // solo ve si est√° cerca
            if (enemigo.x === jugador.x) {
                const minY = Math.min(enemigo.y, jugador.y);
                const maxY = Math.max(enemigo.y, jugador.y);
                for (let y = minY + 1; y < maxY; y++) if (mapa[y][enemigo.x] === 1) return false;
                return true;
            } else if (enemigo.y === jugador.y) {
                const minX = Math.min(enemigo.x, jugador.x);
                const maxX = Math.max(enemigo.x, jugador.x);
                for (let x = minX + 1; x < maxX; x++) if (mapa[enemigo.y][x] === 1) return false;
                return true;
            }
            return false;
        }

        // Colisi√≥n
        function verificarColision() {
            for (const e of enemigos) {
                if (e.x === jugador.x && e.y === jugador.y) {
                    alert('üíÄ ¬°Te atraparon!');
                    reiniciar();
                }
            }
        }

        // Reiniciar juego
        function reiniciar() {
            generarLaberinto();
            jugador = { x: 1, y: 1 };
            generarEnemigos(4);
            dibujarLaberinto();
        }

        // Generar enemigos
        function generarEnemigos(num) {
            enemigos = [];
            for (let i = 0; i < num; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * columnas);
                    y = Math.floor(Math.random() * filas);
                } while (mapa[y][x] !== 0 || (x === 1 && y === 1) || (x === columnas - 2 && y === filas - 2));
                enemigos.push({ x, y });
            }
        }

        // Controles
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') moverJugador(0, -1);
            if (e.key === 'ArrowDown') moverJugador(0, 1);
            if (e.key === 'ArrowLeft') moverJugador(-1, 0);
            if (e.key === 'ArrowRight') moverJugador(1, 0);
        });

        // Inicializaci√≥n
        generarLaberinto();
        generarEnemigos(4);
        dibujarLaberinto();
        setInterval(moverEnemigos, 600);
    </script>
</body>

</html>