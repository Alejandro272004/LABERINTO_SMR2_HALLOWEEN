<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laberinto con Enemigos IA Din√°micos</title>
    <style>
        body {
            background: #0f172a;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: sans-serif;
            color: white;
        }

        #laberinto {
            display: grid;
            grid-template-columns: repeat(20, 30px);
            grid-template-rows: repeat(20, 30px);
            gap: 2px;
            margin-top: 20px;
        }

        .celda {
            width: 30px;
            height: 30px;
            background: #0f172a;
        }

        .pared {
            background: #0c1426;
        }

        .jugador {
            background: #007bff;
            border-radius: 5px;
        }

        .meta {
            background: #28a745;
            border-radius: 5px;
        }

        .enemigo {
            background: #ff0000;
            border-radius: 50%;
        }
    </style>
</head>

<body>
    <h2>üèÉ ¬°Escapa del laberinto!</h2>
    <p>Usa las flechas para moverte. Los enemigos patrullan y te perseguir√°n si te ven.</p>

    <div id="laberinto"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const filas = 20;
            const columnas = 20;
            const laberinto = document.getElementById('laberinto');

            let mapa = [];
            let jugador = { x: 1, y: 1 };
            let enemigos = [];
            let intervaloMovimiento;

            function generarLaberinto(filas, columnas) {
                const grid = Array.from({ length: filas }, () => Array(columnas).fill(1));

                function esValido(f, c) { return f > 0 && f < filas - 1 && c > 0 && c < columnas - 1; }
                function mezclar(arr) { return arr.sort(() => Math.random() - 0.5); }

                function tallar(f, c) {
                    grid[f][c] = 0;
                    const dirs = mezclar([[1, 0], [-1, 0], [0, 1], [0, -1]]);
                    for (const [df, dc] of dirs) {
                        const nf = f + df * 2;
                        const nc = c + dc * 2;
                        if (esValido(nf, nc) && grid[nf][nc] === 1) {
                            grid[f + df][c + dc] = 0;
                            tallar(nf, nc);
                        }
                    }
                }

                tallar(1, 1);
                grid[filas - 2][columnas - 2] = 2;
                return grid;
            }

            function hayCamino(mapa, startX, startY, endX, endY) {
                const visitado = Array.from({ length: filas }, () => Array(columnas).fill(false));
                const cola = [[startX, startY]];
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                visitado[startY][startX] = true;

                while (cola.length) {
                    const [x, y] = cola.shift();
                    if (x === endX && y === endY) return true;
                    for (const [dx, dy] of dirs) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < columnas && ny < filas && !visitado[ny][nx] && mapa[ny][nx] !== 1) {
                            visitado[ny][nx] = true;
                            cola.push([nx, ny]);
                        }
                    }
                }
                return false;
            }

            do {
                mapa = generarLaberinto(filas, columnas);
            } while (!hayCamino(mapa, 1, 1, columnas - 2, filas - 2));

            function generarEnemigos(num) {
                const lista = [];
                for (let i = 0; i < num; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * columnas);
                        y = Math.floor(Math.random() * filas);
                    } while (mapa[y][x] !== 0 || (x === 1 && y === 1) || (x === columnas - 2 && y === filas - 2));
                    lista.push({ x, y });
                }
                return lista;
            }

            enemigos = generarEnemigos(5);

            function dibujarLaberinto() {
                laberinto.innerHTML = '';
                for (let y = 0; y < filas; y++) {
                    for (let x = 0; x < columnas; x++) {
                        const celda = document.createElement('div');
                        celda.classList.add('celda');
                        if (mapa[y][x] === 1) celda.classList.add('pared');
                        if (mapa[y][x] === 2) celda.classList.add('meta');
                        if (x === jugador.x && y === jugador.y) celda.classList.add('jugador');
                        for (const e of enemigos) {
                            if (e.x === x && e.y === y) celda.classList.add('enemigo');
                        }
                        laberinto.appendChild(celda);
                    }
                }
            }

            function moverJugador(dx, dy) {
                const nuevoX = jugador.x + dx;
                const nuevoY = jugador.y + dy;
                if (nuevoX < 0 || nuevoY < 0 || nuevoX >= columnas || nuevoY >= filas) return;
                if (mapa[nuevoY][nuevoX] === 1) return;
                jugador.x = nuevoX;
                jugador.y = nuevoY;

                if (mapa[nuevoY][nuevoX] === 2) {
                    alert("üéâ ¬°Has escapado del laberinto!");
                    reiniciar();
                }

                verificarColision();
                dibujarLaberinto();
            }

            function astar(start, goal) {
                const openSet = [start];
                const cameFrom = {};
                const gScore = {};
                const fScore = {};
                function hash(p) { return `${p.x},${p.y}`; }
                gScore[hash(start)] = 0;
                fScore[hash(start)] = heuristica(start, goal);

                while (openSet.length) {
                    let currentIdx = 0;
                    for (let i = 1; i < openSet.length; i++) {
                        if (fScore[hash(openSet[i])] < fScore[hash(openSet[currentIdx])]) currentIdx = i;
                    }
                    const current = openSet.splice(currentIdx, 1)[0];
                    if (current.x === goal.x && current.y === goal.y) {
                        const path = [];
                        let temp = current;
                        while (hash(temp) in cameFrom) {
                            path.push(temp);
                            temp = cameFrom[hash(temp)];
                        }
                        path.reverse();
                        return path;
                    }

                    const vecinos = [
                        { x: current.x + 1, y: current.y },
                        { x: current.x - 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x, y: current.y - 1 }
                    ];

                    for (const v of vecinos) {
                        if (v.x < 0 || v.y < 0 || v.x >= columnas || v.y >= filas) continue;
                        if (mapa[v.y][v.x] === 1) continue;
                        const tentative_g = gScore[hash(current)] + 1;
                        if (tentative_g < (gScore[hash(v)] || Infinity)) {
                            cameFrom[hash(v)] = current;
                            gScore[hash(v)] = tentative_g;
                            fScore[hash(v)] = tentative_g + heuristica(v, goal);
                            if (!openSet.some(p => p.x === v.x && p.y === v.y)) openSet.push(v);
                        }
                    }
                }
                return [];
            }

            function heuristica(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            function moverEnemigosIA() {
                for (const e of enemigos) {
                    let moved = false;
                    if (lineaVision(e, jugador)) {
                        const camino = astar(e, jugador);
                        if (camino.length > 0) {
                            e.x = camino[0].x;
                            e.y = camino[0].y;
                            moved = true;
                        }
                    }
                    if (!moved) {
                        const opciones = [
                            { x: e.x + 1, y: e.y },
                            { x: e.x - 1, y: e.y },
                            { x: e.x, y: e.y + 1 },
                            { x: e.x, y: e.y - 1 }
                        ].filter(p => p.x >= 0 && p.y >= 0 && p.x < columnas && p.y < filas && mapa[p.y][p.x] === 0);
                        if (opciones.length > 0) {
                            const move = opciones[Math.floor(Math.random() * opciones.length)];
                            e.x = move.x;
                            e.y = move.y;
                        }
                    }
                }
                verificarColision();
                dibujarLaberinto();
            }

            function lineaVision(enemigo, jugador) {
                if (enemigo.x === jugador.x) {
                    const minY = Math.min(enemigo.y, jugador.y);
                    const maxY = Math.max(enemigo.y, jugador.y);
                    for (let y = minY + 1; y < maxY; y++) {
                        if (mapa[y][enemigo.x] === 1) return false;
                    }
                    return true;
                } else if (enemigo.y === jugador.y) {
                    const minX = Math.min(enemigo.x, jugador.x);
                    const maxX = Math.max(enemigo.x, jugador.x);
                    for (let x = minX + 1; x < maxX; x++) {
                        if (mapa[enemigo.y][x] === 1) return false;
                    }
                    return true;
                }
                return false;
            }

            function verificarColision() {
                for (const e of enemigos) {
                    if (e.x === jugador.x && e.y === jugador.y) {
                        alert("üíÄ ¬°Te atraparon!");
                        reiniciar();
                    }
                }
            }

            function reiniciar() {
                jugador = { x: 1, y: 1 };
                do {
                    mapa = generarLaberinto(filas, columnas);
                } while (!hayCamino(mapa, 1, 1, columnas - 2, filas - 2));
                enemigos = generarEnemigos(5);
                dibujarLaberinto();
            }

            document.addEventListener('keydown', e => {
                if (e.key === 'ArrowUp') moverJugador(0, -1);
                if (e.key === 'ArrowDown') moverJugador(0, 1);
                if (e.key === 'ArrowLeft') moverJugador(-1, 0);
                if (e.key === 'ArrowRight') moverJugador(1, 0);
            });

            intervaloMovimiento = setInterval(moverEnemigosIA, 400);
            dibujarLaberinto();
        });
    </script>
</body>

</html>